Para saber mais: Filters


Filter é um dos recursos que fazem parte da especificação de Servlets, a qual padroniza o tratamento de requisições 
e respostas em aplicações Web no Java. Ou seja, tal recurso não é específico do Spring, podendo assim ser utilizado 
em qualquer aplicação Java.

É um recurso muito útil para isolar códigos de infraestrutura da aplicação, como, por exemplo, segurança, logs e 
auditoria, para que tais códigos não sejam duplicados e misturados aos códigos relacionados às regras de negócio 
da aplicação.

Para criar um Filter, basta criar uma classe e implementar nela a interface Filter (pacote jakarta.servlet). Por exemplo:

@WebFilter(urlPatterns = "/api/**")
public class LogFilter implements Filter {

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("Requisição recebida em: " + LocalDateTime.now());
        filterChain.doFilter(servletRequest, servletResponse);
    }

}

O método doFilter é chamado pelo servidor automaticamente, sempre que esse filter tiver que ser executado,
 e a chamada ao método filterChain.doFilter indica que os próximos filters, caso existam outros, podem ser
  executados. A anotação @WebFilter, adicionada na classe, indica ao servidor em quais requisições esse 
  filter deve ser chamado, baseando-se na URL da requisição.

No curso, utilizaremos outra maneira de implementar um filter, usando recursos do Spring que facilitam sua implementação.


...   authorizeRequests deprecated


Atenção!

Na versão 3.0.0 final do Spring Boot uma mudança foi feita no Spring Security, em relação aos códigos que restrigem o controle de acesso.

Ao longo das aulas o método securityFilterChain(HttpSecurity http), declarado na classe SecurityConfigurations, ficou com a seguinte estrutura:

@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    return http.csrf().disable()
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and().authorizeRequests()
            .antMatchers(HttpMethod.POST, "/login").permitAll()
            .anyRequest().authenticated()
            .and().build();
}COPIAR CÓDIGO
Entretanto, desde a versão 3.0.0 final do Spring Boot o método authorizeRequests() se tornou deprecated, devendo ser substituído pelo novo método authorizeHttpRequests(). Da mesma forma, o método antMatchers() deve ser substituído pelo novo método requestMatchers():

@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    return http.csrf().disable()
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and().authorizeHttpRequests()
            .requestMatchers(HttpMethod.POST, "/login").permitAll()
            .anyRequest().authenticated()
            .and().build();
}

...FilterChain


Filtrando requisições


Em relação às classes Filter, conforme abordado ao longo dessa aula, escolha as opções que indicam os objetivos do Filter Chain:

r:

Alternativa correta
Pode ser utilizado para bloquear uma requisição.
É possível interromper o fluxo de uma requisição com o objeto Filter Chain.


Alternativa correta
Representa o conjunto de filtros responsáveis por interceptar requisições.
Esse é um dos objetivos do Filter Chain.


Ordem dos filtros aplicados



Mudanças na versão 3.1
PRÓXIMA ATIVIDADE

ATENÇÃO!

A partir da versão 3.1 do Spring Boot algumas mudanças foram realizadas, em relação às configurações de segurança.
 Caso você esteja utilizando o Spring Boot nessa versão, ou em versões posteriores, o código demonstrado no 
 vídeo anterior vai apresentar um aviso de deprecated, por conta de tais mudanças.

A partir dessa versão, o método securityFilterChain deve ser alterado para:

@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    return http.csrf(csrf -> csrf.disable())
            .sessionManagement(sm -> sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(req -> {
                req.requestMatchers(HttpMethod.POST, "/login").permitAll();
                req.anyRequest().authenticated();
            })
            .addFilterBefore(securityFilter, UsernamePasswordAuthenticationFilter.class)
            .build();
}




Verifique se você cometeu esse erro no seu código! Uma dica é utilizar também o método trim para apagar os espaços em branco da String:
return authorizationHeader.replace("Bearer ", "").trim();






Para saber mais: controle de acesso por url

Na aplicação utilizada no curso não teremos perfis de acessos distintos para os usuários. Entretanto, esse recurso é
 utilizado em algumas aplicações e podemos indicar ao Spring Security que determinadas URLs somente podem ser 
 acessadas por usuários que possuem um perfil específico.

Por exemplo, suponha que em nossa aplicação tenhamos um perfil de acesso chamado de ADMIN, sendo que somente 
usuários com esse perfil possam excluir médicos e pacientes. Podemos indicar ao Spring Security tal 
configuração alterando o método securityFilterChain, na classe SecurityConfigurations, da seguinte
maneira:

@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    return http.csrf().disable()
        .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
        .and().authorizeHttpRequests()
        .requestMatchers(HttpMethod.POST, "/login").permitAll()
        .requestMatchers(HttpMethod.DELETE, "/medicos").hasRole("ADMIN")
        .requestMatchers(HttpMethod.DELETE, "/pacientes").hasRole("ADMIN")
        .anyRequest().authenticated()
        .and().addFilterBefore(securityFilter, UsernamePasswordAuthenticationFilter.class)
        .build();


}
Repare que no código anterior foram adicionadas duas linhas, indicando ao Spring Security que as requisiçõe
s do tipo DELETE para as URLs /medicos e /pacientes somente podem ser executadas por usuários autenticados
e cujo perfil de acesso seja ADMIN.



Para saber mais: controle de acesso por anotações


Outra maneira de restringir o acesso a determinadas funcionalidades, com base no perfil dos usuários, é com 
a utilização de um recurso do Spring Security conhecido como Method Security, que funciona com a utilização 
de anotações em métodos:



@GetMapping("/{id}")
@Secured("ROLE_ADMIN")
public ResponseEntity detalhar(@PathVariable Long id) {
    var medico = repository.getReferenceById(id);
    return ResponseEntity.ok(new DadosDetalhamentoMedico(medico));
}



No exemplo de código anterior o método foi anotado com @Secured("ROLE_ADMIN"), para que apenas usuários com o
 perfil ADMIN possam disparar requisições para detalhar um médico. A anotação @Secured pode ser adicionada em 
 métodos individuais ou mesmo na classe, que seria o equivalente a adicioná-la em todos os métodos.

Atenção! Por padrão esse recurso vem desabilitado no spring Security, sendo que para o utilizar devemos 
adicionar a seguinte anotação na classe Securityconfigurations do projeto:


@EnableMethodSecurity(securedEnabled = true)


Você pode conhecer mais detalhes sobre o recurso de method security na documentação do Spring Security, disponível em: https://docs.spring.io/spring-security/reference/servlet/authorization/method-security.html



exceptions:



Para saber mais: Tratando mais erros
PRÓXIMA ATIVIDADE

No curso não tratamos todos os erros possíveis que podem acontecer na API, mas aqui você encontra uma versão da classe TratadorDeErros abrangendo mais erros comuns:

@RestControllerAdvice
public class TratadorDeErros {

    @ExceptionHandler(EntityNotFoundException.class)
    public ResponseEntity tratarErro404() {
        return ResponseEntity.notFound().build();
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity tratarErro400(MethodArgumentNotValidException ex) {
        var erros = ex.getFieldErrors();
        return ResponseEntity.badRequest().body(erros.stream().map(DadosErroValidacao::new).toList());
    }

    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity tratarErro400(HttpMessageNotReadableException ex) {
        return ResponseEntity.badRequest().body(ex.getMessage());
    }

    @ExceptionHandler(BadCredentialsException.class)
    public ResponseEntity tratarErroBadCredentials() {
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Credenciais inválidas");
    }

    @ExceptionHandler(AuthenticationException.class)
    public ResponseEntity tratarErroAuthentication() {
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Falha na autenticação");
    }

    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity tratarErroAcessoNegado() {
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body("Acesso negado");
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity tratarErro500(Exception ex) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Erro: " +ex.getLocalizedMessage());
    }

    private record DadosErroValidacao(String campo, String mensagem) {
        public DadosErroValidacao(FieldError erro) {
            this(erro.getField(), erro.getDefaultMessage());
        }
    }
}


***

O que aprendemos?
PRÓXIMA ATIVIDADE

Nessa aula, você aprendeu como:
Funcionam os Filters em uma requisição;
Implementar um filter criando uma classe que herda da classe OncePerRequestFilter, do Spring;
Utilizar a biblioteca Auth0 java-jwt para realizar a validação dos tokens recebidos na API;
Realizar o processo de autenticação da requisição, utilizando a classe SecurityContextHolder, do Spring;
Liberar e restringir requisições, de acordo com a URL e o verbo do protocolo HTTP.