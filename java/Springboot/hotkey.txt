intelij

alt+ insert = criar classe

shift + shift = settings =  ctrl + alt + s

alt + enter = atalho create record/class
utilizar o https://start.spring.io/ para configurar

...Mapeando requisições com Spring Boot


Você está trabalhando no desenvolvimento de uma API Rest para uma aplicação de um e-commerce, utilizando o Spring Boot, e cria uma classe Controller da seguinte maneira:

@RequestMapping("/produtos")
public class ProdutoController {

    @GetMapping
    public String produtosEmEstoque() {
        return "Produtos em estoque...";
    }
}
Mas ao executar a aplicação e entrar no endereço http://localhost:8080/produtos, você recebe um erro 404 - Not Found. Por que esse erro ocorreu?

r:
A classe Controller não foi mapeada corretamente.
Para que o Spring reconheça a classe como um Controller, ela deve ser anotada com @Controller ou com @RestController.


***
Nessa aula, você aprendeu como:
Criar um projeto Spring Boot utilizando o site do Spring Initializr;
Importar o projeto no IntelliJ e executar uma aplicação Spring Boot pela classe contendo o método main;
Criar uma classe Controller e mapear uma URL nela utilizando as anotações @RestController e @RequestMapping;
Realizar uma requisição de teste no browser acessando a URL mapeada no Controller.

...CORS

CorsConfiguration


@Configuration
public class CorsConfiguration implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
            .allowedOrigins("http://localhost:3000")
            .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS", "HEAD", "TRACE", "CONNECT");
    }
}


DTO = DATA TRANSFER OBJECT = Para representar os dados que chegam e devolvem na API


...Request Body

Em uma classe Controller existe o seguinte método declarado:

@PostMapping
public void cadastrar(DadosCadastroProduto dados) {
    System.out.println(dados);
}
E nesse projeto foi criado também o DTO DadosCadastroProduto:

public record DadosCadastroProduto(String nome, String descricao, BigDecimal preco){}COPIAR CÓDIGO
Você dispara uma requisição POST, enviando no corpo dela o seguinte JSON:

{
    "preco" : 399.99,
    "descricao" : "Wireless. Cor: branca",
    "nome" : "Fone de ouvido"
}
Mas, ao verificar o console da IDE, percebe que os dados estão chegando todos como null.

Escolha a alternativa CORRETA que indica o porquê os dados estão retornado como nulos:

r:


Faltou anotar o parâmetro dados, recebido no método cadastrar do Controller, com @RequestBody.
Sem essa anotação o Spring não vai ler o corpo da requisição e mapear os campos dele para o DTO recebido como parâmetro.



***

Nessa aula, você aprendeu como:
Mapear requisições POST em uma classe Controller;
Enviar requisições POST para a API utilizando o Insomnia;
Enviar dados para API no formato JSON;
Utilizar a anotação @RequestBody para receber os dados do corpo da requisição em um parâmetro no Controller;
Utilizar o padrão DTO (Data Transfer Object), via Java Records, para representar os dados recebidos em uma requisição POST.

...caso nao encontre 

spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver


...Mudança do MySQL no Maven


Houve uma mudança no Maven em relação à dependência do MySQL, na qual o group-id e o artifact-id foram alterados.

A partir de agora, você deve adicionar a dependência do driver MySQL no arquivo pom.xml da seguinte maneira:

<dependency>
    <groupId>com.mysql</groupId>
    <artifactId>mysql-connector-j</artifactId>
    <scope>runtime</scope>
</dependency>
Além disso, pode acontecer do Spring Boot não encontrar automaticamente o driver do MySQL no projeto, sendo recomendado que você adicione mais uma propriedade no arquivo application.properties:

spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

...YAML
.yml



YAML Configuration
YAML é um outro formato bastante utilizado para definir dados de configuração hierárquica, como é feito no Spring Boot.

Pegando o mesmo exemplo do nosso arquivo application.properties, podemos convertê-lo para YAML alterando seu nome para application.yml e modificando seu conteúdo para:


spring:
    datasource:
        driver-class-name: com.mysql.cj.jdbc.Driver
        url: jdbc:mysql://localhost:3306/clinica
        username: root
        password: root


Com YAML, a configuração se tornou mais legível, pois não contém prefixos repetidos. Além de legibilidade e redução de 
repetição, o uso de YAML facilita o armazenamento de variáveis de configuração de ambiente, conforme recomenda o 12
 Factor App, uma metodologia bastante conhecida e utilizada que define 12 boas práticas para criar uma aplicação
  moderna, escalável e de manutenção simples.

Mas afinal, qual formato usar?
Apesar dos benefícios que os arquivos YAML nos trazem em comparação ao arquivo properties, a decisão de escolher 
um ou outro é de gosto pessoal. Além disso, não é recomendável ter ao mesmo tempo os dois tipos de arquivo em um 
mesmo projeto, pois isso pode levar a problemas inesperados na aplicação.

Caso opte por utilizar YAML, fique atento, pois escrevê-lo no início pode ser um pouco trabalhoso devido às suas 
regras de indentação.


...Embeddable

package med.voll.api.endereco;

import jakarta.persistence.Embeddable;

@Embeddable
public class Endereco {
    private String logradouro;
    private String bairro;
    private String cep;
    private String numero;
    private String complemento;
    private String cidade;
    private String uf;


}



package med.voll.api.medico;

import jakarta.persistence.*;

import med.voll.api.endereco.Endereco;
@Table(name = "medicos")
@Entity(name = "medico")
public class Medico {

    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;
    private String nome;
    private String email;
    private String crm;

    @Enumerated(EnumType.STRING)
    private Especialidade especialidade;

    @Embedded                                        <<<Embedded
    private Endereco endereco;
}

...Interface = Repository

package med.voll.api.medico;

public interface MedicoRepository {
}



stopar ao mexer em db ou adicionar dependencias



mysql> use vollmed_api                                                        
Database changed
mysql> show tables;
+-----------------------+
| Tables_in_vollmed_api |
+-----------------------+
| flyway_schema_history |
| medicos               |
+-----------------------+
2 rows in set (0.01 sec)

mysql> desc medicos;
+---------------+--------------+------+-----+---------+----------------+
| Field         | Type         | Null | Key | Default | Extra          |
+---------------+--------------+------+-----+---------+----------------+
| id            | bigint       | NO   | PRI | NULL    | auto_increment |
| nome          | varchar(100) | NO   |     | NULL    |                |
| email         | varchar(100) | NO   | UNI | NULL    |                |
| crm           | varchar(6)   | NO   | UNI | NULL    |                |
| especialidade | varchar(100) | NO   |     | NULL    |                |
| logradouro    | varchar(100) | NO   |     | NULL    |                |
| bairro        | varchar(100) | NO   |     | NULL    |                |
| cep           | varchar(9)   | NO   |     | NULL    |                |
| complemento   | varchar(100) | YES  |     | NULL    |                |
| numero        | varchar(20)  | YES  |     | NULL    |                |
| uf            | char(2)      | NO   |     | NULL    |                |
| cidade        | varchar(100) | NO   |     | NULL    |                |
+---------------+--------------+------+-----+---------+----------------+
12 rows in set (0.01 sec)

 


 --- @RestController
@RequestMapping("medicos")
public class MedicoController {

    @Autowired
    private MedicoRepository repository;

    @PostMapping
    @Transactional                <-----spring
    public void cadastrar(@RequestBody DadosCadastroMedico dadosMedicos) {
        repository.save(new Medico(dadosMedicos));
    }

}


mysql> select * from medicos;
+----+------------------+---------------------------+--------+---------------+------------+--------+----------+-------------+--------+----+----------+
| id | nome             | email                     | crm    | especialidade | logradouro | bairro | cep      | complemento | numero | uf | cidade   |
+----+------------------+---------------------------+--------+---------------+------------+--------+----------+-------------+--------+----+----------+
|  1 | Rodrigo Ferreira | rodrigo.ferreira@voll.med | 123456 | ORTOPEDIA     | rua 1      | bairro | 12345678 | NULL        | 1      | DF | Brasilia |
+----+------------------+---------------------------+--------+---------------+------------+--------+----------+-------------+--------+----+----------+
1 row in set (0.00 sec)

mysql>


...BeanValidation


  @NotBlank nao é nulo nem vazio e para String

  NotNull Enum

  @Valid = validar DTO herdada

  ...Validando dados   @Valid




Você está trabalhando em um projeto que utiliza o Bean Validation, entretanto, as validações não estão sendo realizadas e as informações
 estão chegando ao banco de dados de maneira inválida.

Analise os seguintes trechos de códigos desse projeto:



@PostMapping
public void cadastrar(@RequestBody DadosCadastroProduto dados) {
    repository.save(new Produto(dados));
}COPIAR CÓDIGO
public record DadosCadastroProduto(
        @NotBlank String nome,
        @NotBlank String descricao,
        @NotNull @DecimalMin(“1.00”) BigDecimal preco
) {
}



Escolha a alternativa CORRETA que identifica o problema mencionado:


Faltou anotar o parâmetro dados, recebido no método cadastrar do Controller, com @Valid.
Sem essa anotação o Spring não vai disparar o processo de validação do Bean Validation.


------------------------/

...CORREÇÃO NON STOP MIGRATION

Para saber mais: Erro na migration


Conforme orientado ao longo dessa aula é importante sempre parar o projeto ao criar os arquivos de migrations, 
para evitar que o Flyway os execute antes da hora, com o código ainda incompleto, causando com isso problemas.

Entretanto, eventualmente pode acontecer de esquecermos de parar o projeto e algum erro acontecer ao tentar 
inicializar a aplicação. Nesse caso será exibido o seguinte erro ao tentar inicializar a aplicação:

Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: 
Error creating bean with name 'flywayInitializer' defined in class path resource [org/springframework/boot/autoconfigure/flyway/FlywayAutoConfiguration$FlywayConfiguration.class]: Validate failed: Migrations have failed validationCOPIAR CÓDIGO
Perceba na mensagem de erro que é indicado que alguma migration falhou, impedindo assim que o projeto seja inicializado corretamente. 
Esse erro também pode acontecer se o código da migration estiver inválido, contendo algum trecho de SQL digitado de maneira incorreta.

Para resolver esse problema será necessário acessar o banco de dados da aplicação e executar o seguinte comando sql:

delete from flyway_schema_history where success = 0;

O comando anterior serve para apagar na tabela do Flyway todas as migrations cuja execução falhou. Após isso,
 basta corrigir o código da migration e executar novamente o projeto.

Obs: Pode acontecer de alguma migration ter criado uma tabela e/ou colunas e com isso o problema vai persistir, 
pois o flyway não vai apagar as tabelas/colunas criadas em migrations que falharam.
 Nesse caso você pode apagar o banco de dados e criá-lo novamente:

drop database vollmed_api;
create database vollmed_api;


------------------/

***

Nessa aula, você aprendeu como:
Adicionar novas dependências no projeto;
Mapear uma entidade JPA e criar uma interface Repository para ela;
Utilizar o Flyway como ferramenta de Migrations do projeto;
Realizar validações com Bean Validation utilizando algumas de suas anotações, como a @NotBlank.


<<<<<Não vai precisar do @Transactional, pois é um método de leitura, apenas carregando registros do banco de dados
não estamos salvando, atualizando nem excluindo informações do banco de dados, não precisa ter uma transação ativa.

...DTO


Para saber mais: DTOs ou entidades?



Estamos utilizando DTOs para representar os dados que recebemos e devolvemos pela API, mas você provavelmente deve estar se perguntando
 “Por que ao invés de criar um DTO não devolvemos diretamente a entidade JPA no Controller?”. Para fazer isso,
  bastaria alterar o método listar no Controller para:

@GetMapping
public List<Medico> listar() {
    return repository.findAll();
}

Desse jeito o código ficaria mais enxuto e não precisaríamos criar o DTO no projeto. Mas, será que isso realmente é uma boa ideia?

Os problemas de receber/devolver entidades JPA
De fato é muito mais simples e cômodo não utilizar DTOs e sim lidar diretamente com as entidades JPA nos controllers.
Porém, essa abordagem tem algumas desvantagens, inclusive causando vulnerabilidade na aplicação para
ataques do tipo Mass Assignment.

Um dos problemas consiste no fato de que, ao retornar uma entidade JPA em um método de um Controller, 
o Spring vai gerar o JSON contendo todos os atributos dela, sendo que nem sempre esse
é o comportamento que desejamos.

Eventualmente podemos ter atributos que não desejamos que sejam devolvidos no JSON, seja por motivos de segurança,
no caso de dados sensíveis, ou mesmo por não serem utilizados pelos clientes da API.

Utilização da anotação @JsonIgnore
Nessa situação, poderíamos utilizar a anotação @JsonIgnore, que nos ajuda a ignorar certas
propriedades de uma classe Java quando ela for serializada para um objeto JSON.

Sua utilização consiste em adicionar a anotação nos atributos que desejamos ignorar quando o JSON for gerado. Por exemplo, 
suponha que em um projeto exista uma entidade JPA Funcionario, na qual desejamos ignorar o atributo salario:

@Getter
@NoArgsConstructor
@EqualsAndHashCode(of = "id")
@Entity(name = "Funcionario")
@Table(name = "funcionarios")
public class Funcionario {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String nome;
    private String email;

    @JsonIgnore
    private BigDecimal salario;

    //restante do código omitido…
}


No exemplo anterior, o atributo salario da classe Funcionario não será exibido nas respostas JSON e o problema estaria solucionado.

Entretanto, pode acontecer de existir algum outro endpoint da API na qual precisamos enviar no 
JSON o salário dos funcionários, sendo que nesse caso teríamos problemas, pois com a anotação
@JsonIgnore tal atributo nunca será enviado no JSON, e ao remover a anotação o atributo 
sempre será enviado. Perdemos, com isso, a flexibilidade de controlar quando determinados
atributos devem ser enviados no JSON e quando não.

DTO
O padrão DTO (Data Transfer Object) é um padrão de arquitetura que era bastante utilizado antigamente em aplicações 
Java distribuídas (arquitetura cliente/servidor) para representar os dados que eram enviados e recebidos entre
as aplicações cliente e servidor.

O padrão DTO pode (e deve) ser utilizado quando não queremos expor todos os atributos de alguma entidade do nosso projeto,
situação igual a dos salários dos funcionários mostrado no exemplo de código anterior. Além disso, com a flexibilidade 
e a opção de filtrar quais dados serão transmitidos, podemos poupar tempo de processamento.

Loop infinito causando StackOverflowError
Outro problema muito recorrente ao se trabalhar diretamente com entidades JPA acontece quando uma entidade possui
algum autorrelacionamento ou relacionamento bidirecional. Por exemplo, considere as seguintes entidades JPA:

@Getter
@NoArgsConstructor
@EqualsAndHashCode(of = "id")
@Entity(name = "Produto")
@Table(name = "produtos")
public class Produto {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String nome;
    private String descricao;
    private BigDecimal preco;

    @ManyToOne
    @JoinColumn(name = “id_categoria”)
    private Categoria categoria;

    //restante do código omitido…
}



@Getter
@NoArgsConstructor
@EqualsAndHashCode(of = "id")
@Entity(name = "Categoria")
@Table(name = "categorias")
public class Categoria {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String nome;

    @OneToMany(mappedBy = “categoria”)
    private List<Produto> produtos = new ArrayList<>();

    //restante do código omitido…
}
Ao retornar um objeto do tipo Produto no Controller, o Spring teria problemas para gerar o JSON desse objeto, causando 
uma exception do tipo StackOverflowError. Esse problema ocorre porque o objeto produto tem um atributo do tipo Categoria,
que por sua vez tem um atributo do tipo List<Produto>, causando assim um loop infinito no processo de serialização para JSON.

Tal problema pode ser resolvido com a utilização da anotação @JsonIgnore ou com a utilização das anotações @JsonBackReference
e @JsonManagedReference, mas também poderia ser evitado com a utilização de um DTO que representa apenas os dados que devem
 ser devolvidos no JSON.


Mass Assignment: Ruby on Rails, NodeJS.
Autobinding: Spring MVC, ASP NET MVC.
Object injection: PHP.


http://localhost:8080/medicos?size=1&page=1 

size=1&
page=1 

sort=nome
sort=nome&size=1&page=1


...Paginação

Para saber mais: parâmetros de paginação


Conforme aprendemos nos vídeos anteriores, por padrão, os parâmetros utilizados para realizar a paginação e a 
ordenação devem se chamar page, size e sort. Entretanto, o Spring Boot permite que os nomes 
de tais parâmetros sejam modificados via configuração no arquivo application.properties.

Por exemplo, poderíamos traduzir para português os nomes desses parâmetros com as seguintes propriedades:

spring.data.web.pageable.page-parameter=pagina
spring.data.web.pageable.size-parameter=tamanho
spring.data.web.sort.sort-parameter=ordem


Com isso, nas requisições que utilizam paginação, devemos utilizar esses nomes que foram definidos.
 Por exemplo, para listar os médicos de nossa API trazendo apenas 5 registros da página 2, 
 ordenados pelo e-mail e de maneira decrescente, a URL da requisição deve ser:

http://localhost:8080/medicos?tamanho=5&pagina=1&ordem=email,desc


---

...Paginação ex

Um colega de trabalho está tendo dificuldades em utilizar o recurso de
 paginação do Spring Boot e pediu sua ajuda.

Ao analisar a classe Controller que ele criou, você identificou o seguinte método:


@GetMapping
public void carregarProdutosCadastrados(Pageable paginacao) {
    repository.findAll().stream().map(DadosListagemProduto::new);
}


Quais problemas no código anterior você identifica? Selecione até duas alternativas.

r:

O parâmetro paginação não está sendo utilizado.
O parâmetro paginação foi declarado corretamente no método do Controller, entretanto, ele não foi utilizado na chamada ao método do repository.


O retorno do método está como void.
Para devolver as informações da API, o método não pode ter void como retorno.

DTO = 


package med.voll.api.medico;


public record DadosListagemMedico(String nome, String email, String crm, Especialidade especialidade) {

    public DadosListagemMedico(Medico medico) {
        this(medico.getNome(), medico.getEmail(), medico.getCrm(), medico.getEspecialidade());
    }
}


***

Nessa aula, você aprendeu como:
Utilizar a anotação @GetMapping para mapear métodos em Controllers que produzem dados;
Utilizar a interface Pageable do Spring para realizar consultas com paginação;
Controlar a paginação e a ordenação dos dados devolvidos pela API com os parâmetros page, size e sort;
Configurar o projeto para que os comandos SQL sejam exibidos no console.


EX: ja feito


Você precisará adicionar um novo método no Controller de paciente:

@GetMapping
public Page<DadosListagemPaciente> listar(@PageableDefault(page = 0, size = 10, sort = {"nome"}) Pageable paginacao) {
    return repository.findAll(paginacao).map(DadosListagemPaciente::new);
}


Também precisará criar o DTO DadosListagemPaciente:

public record DadosListagemPaciente(String nome, String email, String cpf) {
    public DadosListagemPaciente(Paciente paciente) {
        this(paciente.getNome(), paciente.getEmail(), paciente.getCpf());
    }
}



E, caso queira ver os comandos SQL disparados no banco de dados, vai precisar adicionar as seguintes propriedades no arquivo application.properties:

spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true




...PATCH OU PUT

Para saber mais: PUT ou PATCH?


Escolher entre o método HTTP PUT ou PATCH é uma dúvida comum que surge quando estamos desenvolvendo APIs e precisamos criar 
um endpoint para atualização de recursos. Vamos entender as diferenças entre as duas opções e quando utilizar cada uma.

PUT
O método PUT substitui todos os atuais dados de um recurso pelos dados passados na requisição, ou seja, estamos falando 
de uma atualização integral. Então, com ele, fazemos a atualização total de um recurso em apenas uma requisição.


PATCH = ATT PARCIAL
O método PATCH, por sua vez, aplica modificações parciais em um recurso. Logo, é possível modificar apenas uma parte
 de um recurso. Com o PATCH, então, realizamos atualizações parciais, o que torna as opções de atualização mais flexíveis.

Qual escolher?
Na prática, é difícil saber qual método utilizar, pois nem sempre saberemos se um recurso será atualizado parcialmente 
ou totalmente em uma requisição - a não ser que realizemos uma verificação quanto a isso, algo que não é recomendado.

O mais comum então nas aplicações é utilizar o método PUT para requisições de atualização de recursos em uma API,
 sendo essa a nossa escolha no projeto utilizado ao longo deste curso.

 Exclusão lógica = torna inativo

 ...Parâmetros dinâmicos

 Parâmetros dinâmicos
PRÓXIMA ATIVIDADE

Você está trabalhando em uma aplicação com Spring Boot e se depara com o seguinte método:

@DeleteMapping(“/id”)
public void apagar(@PathVariable Long id) {
    repository.deleteById(id);
}

Considerando que a classe Controller a qual esse método pertence está anotada com @RequestMapping(“/produtos”), o que
 acontecerá se uma requisição DELETE for disparada para a API com a url /produtos/0?

 r:

 Ocorrerá um erro 404 - not found.


O parâmetro dinâmico id, adicionado na anotação @DeleteMapping, foi declarado sem estar entre chaves({}). Com isso, 
o Spring vai considerar que a URL para chamar esse método deve ser /produtos/id, ou seja, ele vai considerar
 que a palavra id faz parte da URL, e não que se trata de um parâmetro dinâmico.