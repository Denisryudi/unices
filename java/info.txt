Os executáveis Java precisam da máquina virtual Java.

Os executáveis do mundo Java são portáveis, os do mundo Windows não.
Lembrando portável significa que podem ser executados em vários sistemas operacionais diferentes (Windows, Linux, Mac, etc).

Bytecode:

Já falamos um pouco sobre o Bytecode que é um código de máquina parecido com o Assembly. Talvez você (como eu!) estranhou o nome Bytecode, no entanto, tem uma explicação bem simples para tal. Existe um conjunto de comandos que a máquina virtual Java entende. Esses comandos também são chamados de opcodes (operation code), e cada opcode possui o tamanho de exatamente 1 Byte! E aí temos um opcode de 1 Byte ou, mais simples, Bytecode. :)

O Bytecode é independente do sistema operacional.
 
O Bytecode é executado (interpretado) pela JVM.

sync eclipse
JRE = JVM + bibliotecas

JDK = JRE + ferramentas de desenvolvimento


sobre a compilação e execução de código Java:

*1 - * Durante a compilação acontece uma verificação sintática do código fonte.

*2 - * Na compilação e execução podem aparecer erros.

*3 - * A JVM lê e executa o Bytecode.

*4 - * O compilador gera o Bytecode caso não tenha nenhum erro sintático no código fonte.

todas certas

----

O Pedro está trabalhando pela primeira vez com o sistema operacional Linux, mas está estranhando, pois, o computador não possui uma interface gráfica (só funciona na linha de comando!).

Ou seja, ele precisa compilar e executar um código Java abaixo na linha de comando, no entanto esqueceu os comandos :(

Arquivo Programa.java:

class Programa {

    public static void main(String[] args) {
        System.out.println("Funcionou!!");
    }
}
Quais comandos ele deve usar para compilar e rodar esse código Java?

javac Programa.java
java Programa

Correto! Repare que passamos a extensão do arquivo (.java) para o comando javac:

javac Programa.java
E para chamar a JVM usamos apenas o nome da classe (sem extensão):

usar for somente dentro do laço
ja o while é capaz de ter um sysout fora do laço


Clarice está em dúvida sobre o modo como o break funciona quando utilizado dentro de laços de repetição alinhados.
Escolha a opção que descreve exatamente o funcionamento desse comando nessas situações.

O break irá interromper apenas o laço de repetição mais interno que o contém.

----atributos

Como chamamos, em orientação a objetos, as características de uma classe?

Atributo

Correto, os atributos são as características que especificam uma classe.


--class

A partir do conhecimento adquirido de classes, leia as frases abaixo e responda a opção correta.

V Uma classe é uma especificação de um tipo, definindo atributos e comportamentos.

V Um objeto é uma instância de uma classe onde podemos definir valores para seus atributos.

F Para criar uma instância é obrigatório preencher os valores de todos os atributos.

V Para criar uma instância precisamos usar a palavra chave new



. -----static 


public class Jogador {
    //Código omitido
    private int total = 0;

    public Jogador(//atributos){
       total++;
    }
}
Porém o contador sempre apresenta 1 após inserir um novo jogador. Qual dos motivos abaixo explica a razão desse acontecimento?


Alternativa correta
O total deveria estar como estático, assim sempre que fosse criado um novo objeto do tipo Jogador não seria criado um novo total, 
mantendo o valor correto.


reuso de código
uma vez criado o mesmo tipo não muda.
o que muda é o tipo de referência
polimorfia = mesmo objeto com 2 formas de chegar nele.
Utilizando hierarquias
utilizar um método genérico que chama o método específico
Referências de tipos de classes mais genéricas referenciem objetos mais específicos.

classe abstrata:
Não podem ser instanciadas. Para instanciar, devemos criar primeiro uma classe filha não abstrata.

Uma classe abstrata representa um conceito, algo abstrato, e o compilador não permite instanciar um objeto dessa classe. 
Para instanciar é preciso criar primeiro uma classe filha não abstrata.


Exerc
métodos abstratos

Não possuem corpo (implementação), apenas definem a assinatura.
Correto, um método abstrato define apenas a assinatura (visibilidade, retorno, nome do método e parâmetros).


A herança captura o que é comum e isola aquilo que é diferente entre classes.


O que é verdade sobre classes abstratas? Selecione todas as afirmações verdadeiras:

Alternativa correta
Podem ter métodos concretos (com implementação)
Correto, como podem ter atributos também podem ter métodos concretos!

Alternativa correta
Não podem ser instanciadas
Correto, pois o que é abstrato (a classe) não pode se tornar concreto (objeto). Por isso não podemos instanciar objetos de uma classe abstrata.

Alternativa correta
Podem ter atributos
Correto, podemos sim ter atributos! Uma classes abstrata é uma classe normal, só não pode instanciar (Conta c1 = new Conta();)e pode ter métodos abstratos. O resto continua valendo!

Alternativa correta
Podem ter métodos abstratos (sem implementação)
Correto, como vimos uma classe abstrata pode ter métodos sem implementação. Dessa forma obrigamos um filho implementar o método.


Não podem ter construtores
Errado, pois podem sim ter construtores! Uma classes abstrata é uma classe normal, só não pode instanciar e pode ter métodos abstratos. O resto continua valendo!


----interfaces

Sobre interfaces, qual das alternativas abaixo é VERDADEIRA?

Alternativa correta
Ela é um contrato onde quem assina se responsabiliza por implementar esses métodos (cumprir o contrato)


...


Sobre classes abstratas e interfaces, selecione todas as afirmativas verdadeiras:


Podemos estender apenas uma classe abstrata, mas podemos implementar várias interfaces.

Correto! Existe apenas herança simples em Java, mas podemos implementar quantas interfaces que quisermos..
Todos os métodos de uma interface são abstratos, os de uma classe abstrata podem não ser.


Correto, todos os métodos na interface são sempre abstratos e sempre públicos.
Em uma classe abstratos podemos ter métodos concretos e abstratos.

...


Quanto ao conceito do Polimorfismo marque as alternativas corretas:


É a capacidade de um objeto ser referenciado por vários tipos.
Correta, podemos comunicar com um objeto através de tipos de variáveis diferentes.
Por exemplo, se existir uma classe Gerente que seja filha de Funcionario, um objeto do tipo Gerente pode ser referenciado com o tipo Funcionario também.



É a capacidade de um objeto chamar métodos do seu pai usando super.
Errado, através super deixamos claro que queremos acessar um membro da classe mãe.


Só temos polimorfismo quando uma classe extende de outra, ou seja, apenas via herança.
Errado, vimos que as interfaces são uma alternativa também para ter polimorfismo.


Temos polimorfismo quando uma classe extende de outra ou também quando uma classe implementa uma interface.
Correta, temos polimorfismo via herança ou interface.



......
sobre interfaces

Criar a interface -> método public sempre abstrato -> como: double getValorImposto(); (public e abstract implícito) -> 



Como vimos durante o curso e revisamos durante este capítulo, quais das afirmativas abaixo descreve uma vantagem do uso de interfaces?

Garante que todos os métodos de classes que implementam uma interface possam ser chamados com segurança.
Correto! Isso é a ideia do contrato, garantindo que a classe tenha um comportamento, basta assinar o contrato (implementar a inteface).

...


Qual das afirmativas a seguir representa uma vantagem do uso de composição e interfaces sobre o uso de herança?


A herança é limitada ao polimorfismo, enquanto o uso de interfaces com composição possibilita polimorfismo E reutilização de código.
Errado pois Herança possibilita sim polimorfismo E reutilização.


Com interfaces temos uma alternativa ao polimorfismo, com a composição temos uma alternativa a reutilização de código.
Não há vantagem alguma pode escolher o que você julga melhor.
Errado! Na verdade existem algumas vantagens. Normalmente o uso de interfaces (para definir o contrato e ter polimorfismo) e composição (para ter reutilização de código) 
é mais flexível comparado a herança.


Com composições e interfaces teremos mais flexibilidade com nosso código, já que não nos prenderemos ao acoplamento que a herança propõe.
Correto!

.....
exceções


Marque as alternativas verdadeiras sobre exceções em Java:


Exceções em Java podem ou não ter um nome que a identifique.
Exceções sempre possuem um nome.



Exceções não tratadas caem na pilha de execução procurando por alguém que saiba lidar com ela.
Correto!



Um programa Java sintaticamente correto jamais apresentará erros durante sua execução. Aliás, essa é uma das vantagens da linguagem Java.
Errado, o compilador fará apenas uma verificação sintática. Mesmo assim pode acontecer exceções.



Toda exceção em Java possui um nome que a identifica. Essa abordagem torna seu entendimento mais fácil do que o uso de números mágicos (códigos de erros) como 15, 7012 ou 16.
Correto!

...
uma exceção
Caso não seja tratada, a exceção muda o fluxo de execução do programa.
Alternativa correta! Caso não seja tratada, a exceção muda o fluxo de execução do programa, encerrando-o abruptamente.

--- usa a referencia para chamar um método


... throw

Existe uma hierarquia grande de classes que representam exceções. Por exemplo, ArithmeticException é filha de RuntimeException, que herda de Exception, 
que por sua vez é filha da classe mais ancestral das exceções, Throwable. Conhecer bem essa hierarquia significa saber utilizar exceções em sua aplicação.

Throwable é a classe que precisa ser extendida para que seja possível jogar um objeto na pilha (através da palavra reservada throw)

A hierarquia iniciada com a classe Throwable é dividida em exceções e erros. Exceções são usadas em códigos de aplicação. Erros são usados exclusivamente pela máquina virtual. 
Classes que herdam de ExceptionError são usadas para comunicar erros na máquina virtual.

Desenvolvedores de aplicação não devem criar erros que herdam de ErrorStackOverflowError é um erro da máquina virtual para informar que a pilha de execução não tem mais memória.

Exceções são separadas em duas grandes categorias: aquelas que são obrigatoriamente verificadas pelo compilador e as que não são verificadas. 
As primeiras são denominadas checked e são criadas através do pertencimento a uma hieraquia que não passe por RuntimeException. As segundas são
as unchecked, e são criadas como descendentes de RuntimeException.

r: Isso aí! A primeira frase da afirmação 3 está correta. Contudo, classes que comunicam erros da máquina virtual herdam de Error. 
Fala pro Miguel assistir os vídeos novamente!

checked obrigatorio tratar
unchecked o desenvolvedor escolher

a - throw

b - finally

c - catch

d - throws

e - try

todas


...finally

Veja as afirmações sobre o bloco finally:

a - O bloco finally é opcional quando há bloco catch.

b - O bloco finally sempre será executado (sem ou com exceção).

c - O bloco finally só será executado sem exceção.

d - O bloco finally é tipicamente utilizado para fechar um recurso como conexão ou transação.

Quais são corretas?

a, b, d


Correto, é opcional, executa sempre (sem ou com exceção) e é tipicamente utilizado para fechar um recurso.


...try catch finally


try {}
finally {}

Correto, no tratamento o bloco catch é opcional quando tem o bloco finally.

try {}
catch(SacaException | DepositaException  ex) {}

Correto, um tratamento com try e multi-catch.



Alternativa correta
try {}
finally {}

Correto, no tratamento o bloco catch é opcional quando tem o bloco finally.



try {}
catch(SacaException ex) {}
catch(DepositaException ex) {}
finally {}

Correto, temos um try com dois blocos catch (clássicos) e o bloco finally.

...try-with-resources

O que está garantido quando usamos o try-with-resources?

try(Conexao con = new Conexao()) {
     con.leDados();
}


O bloco finally é criado automaticamente.
Correto, automaticamente é criado um bloco finally. Nele é chamado o método close() do recurso.

O recurso precisa implementar o método close().
Correto, automaticamente é criado um bloco finally. Nele é chamado o método close() do recurso.

***
Nessa aula, aprendemos:

que existe um bloco finally, útil para o fechamento de recursos (como conexão);
quando há um bloco finally o bloco catch é opcional;
que o bloco finally é sempre executado, sem ou com exceção;
como usar o try-with-resources.


...FQN full

O que é o FQN mesmo?



Alternativa correta
É o nome completo da classe composto pelo nome do pacote e o nome da classe.


Correto, o FQN (Full Qualified Name) é nome completo da classe, composto pelo nome do pacote e o nome da classe.
FQN = Nome Pacote . Nome Simples da Classe

...package

packages são diretórios que tem significado especial dentro do código fonte Java (b), a palavra chave package deve ser 
a primeira declaração(c) e packages servem para organização e agrupar as classes e interfaces (d).

...FQN

O seu amigo Pedro trabalha na empresa Uberdist no projeto com o apelido udnotas. O Pedro também mencionou que a empresa possui um site com o endereço uberdist.com.br.

O Pedro está com dúvida sobre a nomenclatura do package. Qual nome faria mais sentido e é considerado boa prática?



br.com.uberdist.udnotas


Correto, sempre seguindo a regra:
NOME_DO_SITE_AO_CONTRARIO.NOME_DO_PROJETO

...estrutura FQN


Veja a estrutura seguinte:

src
  br
    gov
      rio
        sicis
          Usuario.javaCOPIAR CÓDIGO
E o código fonte da classe Usuario:

//AQUI

public class Usuario {

  //atributos e métodos omitidos
}COPIAR CÓDIGO
Assumindo que a pasta src é a raiz do nosso código fonte. O que devemos colocar no lugar de //AQUI para compilar a classe Usuario com sucesso?

r: 

package br.gov.rio.sicis;

Correto, o package possui todos os nomes dos diretórios separado pelo caracter . (ponto).

......* package


Vimos agora que em um arquivo de classe ou interface existe a declaração do package, a declaração do import e a definição da classe.

a) Só pode ter uma declaração package por arquivo

b) A declaração do import é opcional

c) É possível repetir a declaração import para importações de packages diferentes

d) A definição da classe sempre deve vir por último (após package e import)

Quais afirmações estão corretas?


b, c, d
Errado, pois falta a opção a:


Só pode ter uma declaração package no código fonte e, além disso, a declaração deve ser a primeira clausula no código fonte (só comentários pode ter antes do package).
Alternativa correta
Todas



a, c e d
Errado, pois falta a opção b:
A declaração do import é opcional
Não é preciso usar o import (porém útil). Sempre podemos usar o FQN da classe.


a e d
Errado, pois faltam as opções b e c:
A declaração do import é opcional (b) e é possível repetir a declaração import para importações de packages diferentes (c).

...package

No desenvolvimento em Java, organizamos nossas classes em pacotes. Sobre esse tema é correto afirmar que:

O modificador default do Java restringe acesso a nível de pacote. Logo, se não for definido algum modificador, seja na classe, método, ou atributo,
apenas classes do mesmo pacote podem acessar essas informações.
Correto, com default apenas classes do mesmo pacote podem acessar essas informações.


Quando um projeto utiliza pacotes, podemos usar o import de outras classes para sua utilização.
Correto! O import facilita o uso da classe pois não precisamos do Full Qualified Name.


Por organização e pela convenção adotada, precisamos seguir o domínio da empresa. Ou seja, se a empresa tem como domínio alura.com.br, os pacotes devem ser subpacotes de br.com.alura.
Correto, mas existem exceções (poucas).

***

O que aprendemos?

packages servem para organizar o nosso código
packages fazem parte do FQN (Full Qualified Name) da classe
o nome completo da classe (FQN) é composto de: PACKAGE.NOME_SIMPLES_CLASSE
a definição do package deve ser a primeira declaração no código fonte
para facilitar o uso de classes de outros packages podemos importá-los
os imports ficam logo após da declaração do package
a nomenclatura padrão é usar o nome do domínio na web ao contrário junto com o nome do projeto, por exemplo:
br.com.caelum.geradornotas
br.com.alura.gnarus
br.gov.rj.notas
de.adidas.lagerCOPIAR CÓDIGO
Uma vez organizado as nossas classes podemos revisar os modificadores de visibilidades que dependem dos pacotes. Vamos continuar?

protected = publico para os filhos

...modificadores

Sobre os modificadores de acesso do Java é correto afirmar que:

Alternativa correta
Temos quatro modificadores: private, protected, default e public. Onde a ordem do MAIS restritivo para o MENOS restritivo é: private, default, protected e public.

...modificador1

Qual modificador é visível nos seguintes lugares?

Classe   Package   Classe Filho   Qualquer Package
────────────────────────────────────────────
 ✔        ✔         ✔             ✘
───────────────────────────────────────────

protected


Correto! 
O modificador protected funciona igual ao *<<package private>> mas adiciona a visibilidade para os filhos (chamado de "publico para os filhos").


...modificador2

E agora, qual modificador é visível nos seguintes lugares?

Classe   Package   Classe Filho   Qq Package
────────────────────────────────────────────
 ✔        ✔         ✘             ✘
────────────────────────────────────────────


<<package private>> (ausência do modificador)

A ausência do modificador, também chamado de package private ou default, o membro fica visível na classe e no package, mas é invisível fora do pacote (nem para filhos).

***

Nessa aula falamos novamente sobre visibilidade e aprendemos:

existem 3 palavras chaves relacionado com a visibilidade: private, protected, public
existem 4 níveis de visibilidade (de menor para maior):
private (visível apenas na classe)
<<package private>> (visível na classe E em qualquer outro membro do mesmo pacote, podendo ser chamado de default)
protected (visível na classe E em qualquer outro membro do mesmo pacote E para qualquer filho)
public (visível em qualquer pacote)
os modificadores podem ser usados na definição da classe, atributo, construtor e método


...javadoc

Leia as afirmações com atenção:

a) É preciso ter instalado o JDK para poder gerar a documentação javadoc.

b) O javadoc é uma documentação escrita pelo desenvolvedor para desenvolvedores.

c) Todos os membros da classe são contemplados no javadoc. ---

d) Existem tags especias para marcar o autor ou a versão da classe.

Todas são verdadeiras exceto:


c.
Não é verdadeira pois apenas os membros "públicos" são contemplados no javadoc. Outros membros (não públicos) são considerados detalhes da implementação
 e não podem ser utilizados por outras classes.

 ***

 Já vimos nessa aula algumas tags (ou anotações) do javadoc como @version ou @author. Segue a lista completa:

@author (usado na classe ou interface)
@version (usado na classe ou interface)
@param (usado no método e construtor)
@return (usado apenas no método)
@exception ou @throws (no método ou construtor)
@see
@since
@serial
@deprecated
Importante é que as tags do javadoc existem apenas para padronizar alguns dados fundamentais do seu código fonte como o autor e a versão.

Outras anotações
Nos cursos você também já viu uma anotação fora do javadoc, a anotação @Override. Essa anotação é considerada uma configuração, nesse caso interpretado pelo compilador.

As anotações vão muito além das tags javadoc e são muito mais sofisticadas e poderosas. Elas só entraram na plataforma Java a partir da versão 1.5 enquanto o javadoc está presente desde o nascimento da plataforma Java. O interessante é que as anotações foram inspirados pelas tags do javadoc.

Se você ainda não está seguro sobre o uso das anotações, fique tranquilo pois você verá ainda muitas usadas pelas bibliotecas por ai para definir dados e configurações. Aguarde!



...toString()

Qual é o objetivo do método toString() da classe Object?

Alternativa correta
O método toString() existe para ser sobrescrito.
Correto, é boa prática sobrescrever o método para dar um significado maior do que a saída padrão desse método.


O método toString() existe para devolver uma informação sobre o estado do objeto.
Correto, o método toString deve devolver informações sobre o estado do objeto. É útil para a depuração no desenvolvimento.



---array

heap (memoria objeto)
array é um objeto


...ref. array

4.


Você está se preparando para a certificação Java e passou pelo código seguinte:

ContaPoupanca[] contas = new ContaPoupanca[10];
ContaPoupanca cp1 = new ContaPoupanca(11,22);
ContaPoupanca cp2 = new ContaPoupanca(33,44);

contas[0] = cp1;
contas[1] = cp1;
contas[4] = cp2;
contas[5] = cp2;

ContaPoupanca ref1 = contas[1];
ContaPoupanca ref2 = contas[4];COPIAR CÓDIGO
Quantas referências apontam para a ContaPoupanca com a agencia 33 e número 44?

Bingo! Vamos contar?
r: 

1) ContaPoupanca cp2 = new ContaPoupanca(33, 44);
2) contas[4] = cp2;
3) contas[5] = cp2;
4) ContaPoupanca ref2 = contas[4];

*
Até agora vimos a forma "classica" de criar um objeto array usando a palavra chave new, por exemplo:

int[] numeros = new int[5];
numeros[0] = 1;
numeros[1] = 2;
numeros[2] = 3;
numeros[3] = 4;
numeros[4] = 5;
COPIAR CÓDIGO
No entanto também há uma forma literal. Literal, nesse contexto, significa usar valores diretamente, menos burocrático, mais direito. Veja a diferença:

int[] refs = {1,2,3,4,5};
COPIAR CÓDIGO
Usamos as chaves {} para indicar que se trata de um array e os valores já ficam declarados dentro das chaves.

***

Nessa aula sobre Arrays aprendemos:

Um array é uma estrutura de dados e serve para guardar elementos (valores primitivos ou referências)
Arrays usam colchetes ([]) sintaticamente
Arrays têm um tamanho fixo!
Um array também é um objeto!
Arrays são zero-based (o primeiro elemento se encontra na posição 0)
Um array é sempre inicializado com os valores padrões.
Ao acessar uma posição inválida recebemos a exceção ArrayIndexOutOfBoundException
Arrays possuem um atributo length para saber o tamanho
A forma literal de criar uma Array, com o uso de chaves {}.
No próximo capítulo falaremos mais um pouco sobre arrays (do tipo Object) e veremos como funciona esse parâmetro do método main.